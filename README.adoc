= AffineScript

image:https://img.shields.io/badge/License-MPL_2.0-blue.svg[MPL-2.0,link="https://opensource.org/licenses/MPL-2.0"]
image:https://img.shields.io/badge/Philosophy-Palimpsest-purple.svg[Palimpsest,link="https://github.com/hyperpolymath/palimpsest-licence"]


:toc: macro
:toclevels: 3
:icons: font
:source-highlighter: rouge

A Rust-inspired programming language combining affine types, dependent types, row polymorphism, and extensible effectsâ€”compiling to WebAssembly with no garbage collector.

[.lead]
AffineScript brings the safety of linear types, the expressiveness of dependent types, and the modularity of algebraic effects into a cohesive, practical language.

**ðŸ“– New to this repository?** See link:NAVIGATION.adoc[Navigation Guide] for directory structure and quick links.

toc::[]

== Overview

AffineScript is designed for systems programming where correctness matters. It combines ideas from:

* **Rust** â€” ownership, borrowing, no GC
* **Idris/Agda** â€” dependent types, totality checking
* **PureScript/Koka** â€” row polymorphism, algebraic effects
* **Linear Haskell** â€” quantitative type theory

=== Key Features

[cols="1,2"]
|===
|Feature |Description

|**Affine Types**
|Track resource usage with quantities: `0` (erased), `1` (linear), `Ï‰` (unrestricted)

|**Dependent Types**
|Types that depend on valuesâ€”length-indexed vectors, refinement types

|**Row Polymorphism**
|Extensible records with `{x: Int, ..r}` syntax for flexible data structures

|**Extensible Effects**
|User-defined effects with `effect` declarations and `handle`/`resume`

|**Ownership**
|`own`, `ref`, `mut` modifiers for memory safety without GC

|**Totality Checking**
|Mark functions as `total` to prove termination

|**WebAssembly Target**
|Compiles to WASM for portable, high-performance execution
|===

== Try It Now! ðŸš€

**Browser Playground**: The AffineScript interpreter runs directly in your browser via js_of_ocaml!

* **Try it**: link:https://github.com/hyperpolymath/affinescript-playground[affinescript-playground]
* **No installation needed** - open `test.html` in any browser
* **Full interpreter** - all features work client-side
* **Interactive** - edit code and see results instantly

Example code you can try:
[source,affinescript]
----
// Exception handling
try {
  10 / 0
} catch {
  DivisionByZero => 42
}

// Recursion
fn factorial(n: Int) -> Int {
  if n <= 1 { 1 } else { n * factorial(n - 1) }
}
factorial(5)  // Returns: 120
----

== Language Examples

=== Hello World with Effects

[source,affinescript]
----
effect IO {
  fn print(s: String);
  fn println(s: String);
}

fn main() -> () / IO {
  println("Hello, AffineScript!");
}
----

=== Ownership and Resource Safety

[source,affinescript]
----
type File = own { fd: Int }

fn open(path: ref String) -> Result[own File, IOError] / IO + Exn[IOError] {
  Ok(File { fd: 42 })
}

fn read(file: ref File) -> Result[String, IOError] / IO {
  // Borrows file â€” doesn't consume it
  Ok("file contents")
}

fn close(file: own File) -> Result[(), IOError] / IO {
  // Consumes file â€” can't use it after this
  Ok(())
}

// Safe resource handling with RAII pattern
fn withFile[T](
  path: ref String,
  action: (ref File) -> Result[T, IOError] / IO
) -> Result[T, IOError] / IO {
  let file = open(path)?;
  let result = action(ref file);
  close(file)?;
  result
}
----

=== Row Polymorphism

[source,affinescript]
----
// Works on any record that has a 'name' field
fn greet[..r](person: {name: String, ..r}) -> String / Pure {
  "Hello, " ++ person.name
}

// Extend records while preserving other fields
fn fullName[..r](
  person: {first: String, last: String, ..r}
) -> {first: String, last: String, fullName: String, ..r} / Pure {
  {fullName: person.first ++ " " ++ person.last, ..person}
}

fn main() -> () / Pure {
  let alice = {name: "Alice", age: 30, role: "Engineer"};
  let bob = {name: "Bob", department: "Sales"};

  // Both work despite different record shapes
  let greeting1 = greet(alice);  // âœ“
  let greeting2 = greet(bob);    // âœ“
}
----

=== Dependent Types: Length-Indexed Vectors

[source,affinescript]
----
type Vec[n: Nat, T: Type] =
  | Nil : Vec[0, T]
  | Cons(head: T, tail: Vec[n, T]) : Vec[n + 1, T]

// Can only be called on non-empty vectors â€” enforced by types!
total fn head[n: Nat, T](v: Vec[n + 1, T]) -> T / Pure {
  match v {
    Cons(h, _) => h
  }
}

// Concatenate: result length is sum of input lengths
total fn append[n: Nat, m: Nat, T](
  a: Vec[n, T],
  b: Vec[m, T]
) -> Vec[n + m, T] / Pure {
  match a {
    Nil => b,
    Cons(h, t) => Cons(h, append(t, b))
  }
}
----

== Project Status

=== Implementation Progress

[cols="2,1,3"]
|===
|Component |Status |Details

|**Lexer**
|âœ… Complete
|sedlex-based, Unicode support, full test coverage

|**Parser Grammar**
|âœ… Complete
|615-line Menhir grammar covering entire syntax

|**Abstract Syntax Tree**
|âœ… Complete
|395 lines representing all language constructs

|**Error Handling**
|âœ… Complete
|Rich diagnostics with 50+ error codes, colored output

|**CLI Interface**
|âœ… Complete
|`lex`, `parse`, `check`, `eval`, `compile`, `fmt`, `lint`, `repl`

|**Name Resolution**
|âœ… Complete
|Module loader with stdlib imports, scope analysis

|**Type Checker**
|âœ… 98% Complete
|Bidirectional inference with effect system, subsumption

|**Effect System**
|âœ… Complete
|Pure/impure separation, effect polymorphism, safety enforcement

|**Borrow Checker**
|âœ… 95% Complete
|Use-after-move detection, ownership tracking

|**Trait System**
|ðŸš§ 70% Complete
|Trait registry, impl validation, method resolution

|**Interpreter**
|âœ… 85% Complete
|Pattern matching, control flow, basic effect handlers

|**Code Generation**
|ðŸš§ 75% Complete
|WASM IR, binary encoder, WASI I/O runtime

|**Standard Library**
|ðŸš§ 65% Complete
|Core, Result, Option, Math, Traits, Effects modules

|**Formatter**
|âœ… Complete
|AST-based pretty printer with configurable style

|**Linter**
|âœ… Complete
|4 lint rules: unused vars, missing effects, dead code, naming

|**IDE Tooling**
|âœ… Complete
|VSCode extension, LSP server, Tree-sitter grammar
|===

=== What Works Today

The AffineScript compiler is **85% complete** with a working end-to-end toolchain:

**âœ… Complete Features:**

* **Full Language Frontend** â€” Lex, parse, name resolution with module system
* **Type Checking** â€” Bidirectional inference with effect tracking and subsumption
* **Effect System** â€” Pure/impure separation enforced at compile time
* **Borrow Checking** â€” Use-after-move detection with ownership tracking
* **WebAssembly Compilation** â€” Compiles `.as` files to `.wasm` with WASI I/O
* **Tree-Walking Interpreter** â€” Run AffineScript code directly with `eval`
* **Interactive REPL** â€” Read-eval-print loop for experimentation
* **Code Formatting** â€” AST-based pretty printer (`fmt` command)
* **Static Analysis** â€” Linter with 4 rules (`lint` command)
* **IDE Support** â€” VSCode extension, LSP server, Tree-sitter grammar

**ðŸš§ In Progress:**

* **Trait System** (70%) â€” Method resolution and generic trait bounds
* **Standard Library** (65%) â€” Expanding Core, Collections, and I/O modules
* **Effect Handlers** â€” Delimited continuations for full `resume` support

[source,bash]
----
# Tokenize a file
dune exec affinescript -- lex examples/hello.as

# Parse and display AST
dune exec affinescript -- parse examples/ownership.as

# Type check a file
dune exec affinescript -- check examples/hello.as

# Run with interpreter
dune exec affinescript -- eval examples/factorial.as

# Compile to WebAssembly
dune exec affinescript -- compile examples/hello.as -o hello.wasm

# Format code
dune exec affinescript -- fmt examples/hello.as

# Lint for code quality
dune exec affinescript -- lint examples/hello.as

# Start REPL
dune exec affinescript -- repl
----

== IDE Support

AffineScript has **complete IDE tooling** for a professional development experience:

=== VSCode Extension

Located in `editors/vscode/`:

* **Syntax Highlighting** â€” TextMate grammar with full language support
* **Commands** â€” Check, eval, compile, format with keyboard shortcuts
* **LSP Integration** â€” Real-time diagnostics powered by affinescript-lsp
* **Language Configuration** â€” Auto-closing brackets, comment toggling

**Installation:**
[source,bash]
----
cd editors/vscode
npm install
code --install-extension .
----

=== Language Server (LSP)

Located in `tools/affinescript-lsp/`:

* **Real-time Diagnostics** â€” Type errors, borrow errors shown as you type
* **Powered by Rust** â€” Uses tower-lsp for LSP protocol
* **Compiler Integration** â€” Calls `affinescript check` for analysis

**Build:**
[source,bash]
----
cd tools/affinescript-lsp
cargo build --release
----

=== Tree-sitter Grammar

Located in `editors/tree-sitter-affinescript/`:

* **Incremental Parsing** â€” Fast syntax analysis for modern editors
* **Syntax Highlighting** â€” Queries for Neovim, Emacs, Helix
* **Full Coverage** â€” All AffineScript constructs supported

**Installation (Neovim):**
[source,lua]
----
require('nvim-treesitter.configs').setup {
  parser_install_dir = "~/.local/share/nvim/site/parser",
  ensure_installed = { "affinescript" }
}
----

=== Code Quality Tools

* **Formatter** (`affinescript fmt`) â€” AST-based pretty printer
* **Linter** (`affinescript lint`) â€” 4 static analysis rules:
  ** L001: Unused variables
  ** L002: Missing effect annotations
  ** L003: Dead code after return
  ** L004: Naming convention violations

== Building

=== Prerequisites

* OCaml 5.1+
* Dune 3.0+
* opam packages: `sedlex`, `menhir`, `ppx_deriving`, `cmdliner`, `alcotest`

=== Commands

[source,bash]
----
# Build
dune build

# Run tests
dune runtest

# Format code
dune fmt

# Generate documentation
dune build @doc

# Run compiler
dune exec affinescript -- <command> <file>
----

== Repository Structure

[source]
----
affinescript/
â”œâ”€â”€ lib/                    # Core compiler library
â”‚   â”œâ”€â”€ ast.ml              # Abstract syntax tree (395 lines)
â”‚   â”œâ”€â”€ token.ml            # Token definitions (222 lines)
â”‚   â”œâ”€â”€ lexer.ml            # Lexer â€” sedlex-based (323 lines)
â”‚   â”œâ”€â”€ parser.mly          # Parser â€” Menhir grammar (615 lines)
â”‚   â”œâ”€â”€ parse.ml            # Parser driver
â”‚   â”œâ”€â”€ span.ml             # Source location tracking
â”‚   â””â”€â”€ error.ml            # Diagnostics and error handling
â”œâ”€â”€ bin/                    # CLI executable
â”‚   â””â”€â”€ main.ml             # Command-line interface
â”œâ”€â”€ test/                   # Test suite
â”‚   â”œâ”€â”€ test_lexer.ml       # Lexer tests (~145 cases)
â”‚   â””â”€â”€ test_parser.ml      # Parser tests (~80 cases)
â”œâ”€â”€ examples/               # Example programs
â”‚   â”œâ”€â”€ hello.as            # Basic IO effect
â”‚   â”œâ”€â”€ ownership.as        # Resource management
â”‚   â”œâ”€â”€ rows.as             # Row polymorphism
â”‚   â””â”€â”€ vectors.as          # Dependent types
â”œâ”€â”€ docs/                   # Documentation
â”‚   â””â”€â”€ wiki/               # Compiler & language documentation
â””â”€â”€ affinescript-spec.md    # Complete language specification (53KB)
----

== Documentation

* `affinescript-spec.md` â€” Complete language specification
* `docs/wiki/compiler/` â€” Compiler architecture and phase documentation
* `docs/wiki/language-reference/` â€” Language feature guides
* `docs/wiki/tutorials/` â€” Getting started guides

== Design Philosophy

. **Safety by default** â€” Ownership and effects make unsafe code explicit
. **Types as documentation** â€” Dependent types encode invariants in the type system
. **Composable abstractions** â€” Row polymorphism and effects compose cleanly
. **No runtime cost for safety** â€” Linear types enable compile-time resource management
. **Partial by default** â€” Functions may diverge unless marked `total`

== License

SPDX-License-Identifier: PMPL-1.0-or-later

== See Also

* link:ROADMAP.adoc[Development Roadmap]
* link:affinescript-spec.md[Language Specification]
