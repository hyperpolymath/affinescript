= AffineScript

image:https://img.shields.io/badge/License-MPL_2.0-blue.svg[MPL-2.0,link="https://opensource.org/licenses/MPL-2.0"]
image:https://img.shields.io/badge/Philosophy-Palimpsest-purple.svg[Palimpsest,link="https://github.com/hyperpolymath/palimpsest-licence"]


:toc: macro
:toclevels: 3
:icons: font
:source-highlighter: rouge

A Rust-inspired programming language combining affine types, dependent types, row polymorphism, and extensible effectsâ€”compiling to WebAssembly with no garbage collector.

[.lead]
AffineScript brings the safety of linear types, the expressiveness of dependent types, and the modularity of algebraic effects into a cohesive, practical language.

toc::[]

== Overview

AffineScript is designed for systems programming where correctness matters. It combines ideas from:

* **Rust** â€” ownership, borrowing, no GC
* **Idris/Agda** â€” dependent types, totality checking
* **PureScript/Koka** â€” row polymorphism, algebraic effects
* **Linear Haskell** â€” quantitative type theory

=== Key Features

[cols="1,2"]
|===
|Feature |Description

|**Affine Types**
|Track resource usage with quantities: `0` (erased), `1` (linear), `Ï‰` (unrestricted)

|**Dependent Types**
|Types that depend on valuesâ€”length-indexed vectors, refinement types

|**Row Polymorphism**
|Extensible records with `{x: Int, ..r}` syntax for flexible data structures

|**Extensible Effects**
|User-defined effects with `effect` declarations and `handle`/`resume`

|**Ownership**
|`own`, `ref`, `mut` modifiers for memory safety without GC

|**Totality Checking**
|Mark functions as `total` to prove termination

|**WebAssembly Target**
|Compiles to WASM for portable, high-performance execution
|===

== Language Examples

=== Hello World with Effects

[source,affinescript]
----
effect IO {
  fn print(s: String);
  fn println(s: String);
}

fn main() -> () / IO {
  println("Hello, AffineScript!");
}
----

=== Ownership and Resource Safety

[source,affinescript]
----
type File = own { fd: Int }

fn open(path: ref String) -> Result[own File, IOError] / IO + Exn[IOError] {
  Ok(File { fd: 42 })
}

fn read(file: ref File) -> Result[String, IOError] / IO {
  // Borrows file â€” doesn't consume it
  Ok("file contents")
}

fn close(file: own File) -> Result[(), IOError] / IO {
  // Consumes file â€” can't use it after this
  Ok(())
}

// Safe resource handling with RAII pattern
fn withFile[T](
  path: ref String,
  action: (ref File) -> Result[T, IOError] / IO
) -> Result[T, IOError] / IO {
  let file = open(path)?;
  let result = action(ref file);
  close(file)?;
  result
}
----

=== Row Polymorphism

[source,affinescript]
----
// Works on any record that has a 'name' field
fn greet[..r](person: {name: String, ..r}) -> String / Pure {
  "Hello, " ++ person.name
}

// Extend records while preserving other fields
fn fullName[..r](
  person: {first: String, last: String, ..r}
) -> {first: String, last: String, fullName: String, ..r} / Pure {
  {fullName: person.first ++ " " ++ person.last, ..person}
}

fn main() -> () / Pure {
  let alice = {name: "Alice", age: 30, role: "Engineer"};
  let bob = {name: "Bob", department: "Sales"};

  // Both work despite different record shapes
  let greeting1 = greet(alice);  // âœ“
  let greeting2 = greet(bob);    // âœ“
}
----

=== Dependent Types: Length-Indexed Vectors

[source,affinescript]
----
type Vec[n: Nat, T: Type] =
  | Nil : Vec[0, T]
  | Cons(head: T, tail: Vec[n, T]) : Vec[n + 1, T]

// Can only be called on non-empty vectors â€” enforced by types!
total fn head[n: Nat, T](v: Vec[n + 1, T]) -> T / Pure {
  match v {
    Cons(h, _) => h
  }
}

// Concatenate: result length is sum of input lengths
total fn append[n: Nat, m: Nat, T](
  a: Vec[n, T],
  b: Vec[m, T]
) -> Vec[n + m, T] / Pure {
  match a {
    Nil => b,
    Cons(h, t) => Cons(h, append(t, b))
  }
}
----

== Project Status

=== Implementation Progress

[cols="2,1,3"]
|===
|Component |Status |Details

|**Lexer**
|âœ… Complete
|sedlex-based, Unicode support, full test coverage

|**Parser Grammar**
|âœ… Complete
|615-line Menhir grammar covering entire syntax

|**Abstract Syntax Tree**
|âœ… Complete
|395 lines representing all language constructs

|**Error Handling**
|âœ… Complete
|Rich diagnostics with 50+ error codes, colored output

|**CLI Interface**
|âœ… Complete
|`lex`, `parse`, `check`, `compile` commands

|**Name Resolution**
|ðŸ”² Planned
|Scope analysis, module resolution

|**Type Checker**
|ðŸ”² Planned
|Bidirectional inference, constraint solving

|**Borrow Checker**
|ðŸ”² Planned
|Non-lexical lifetimes, linearity enforcement

|**Code Generation**
|ðŸ”² Planned
|WASM backend
|===

=== What Works Today

The compiler frontend is complete. You can:

* **Tokenize** AffineScript source files
* **Parse** to a full abstract syntax tree
* **Pretty-print** ASTs for debugging

[source,bash]
----
# Tokenize a file
dune exec affinescript -- lex examples/hello.as

# Parse and display AST
dune exec affinescript -- parse examples/ownership.as
----

== Building

=== Prerequisites

* OCaml 5.1+
* Dune 3.0+
* opam packages: `sedlex`, `menhir`, `ppx_deriving`, `cmdliner`, `alcotest`

=== Commands

[source,bash]
----
# Build
dune build

# Run tests
dune runtest

# Format code
dune fmt

# Generate documentation
dune build @doc

# Run compiler
dune exec affinescript -- <command> <file>
----

== Repository Structure

[source]
----
affinescript/
â”œâ”€â”€ lib/                    # Core compiler library
â”‚   â”œâ”€â”€ ast.ml              # Abstract syntax tree (395 lines)
â”‚   â”œâ”€â”€ token.ml            # Token definitions (222 lines)
â”‚   â”œâ”€â”€ lexer.ml            # Lexer â€” sedlex-based (323 lines)
â”‚   â”œâ”€â”€ parser.mly          # Parser â€” Menhir grammar (615 lines)
â”‚   â”œâ”€â”€ parse.ml            # Parser driver
â”‚   â”œâ”€â”€ span.ml             # Source location tracking
â”‚   â””â”€â”€ error.ml            # Diagnostics and error handling
â”œâ”€â”€ bin/                    # CLI executable
â”‚   â””â”€â”€ main.ml             # Command-line interface
â”œâ”€â”€ test/                   # Test suite
â”‚   â”œâ”€â”€ test_lexer.ml       # Lexer tests (~145 cases)
â”‚   â””â”€â”€ test_parser.ml      # Parser tests (~80 cases)
â”œâ”€â”€ examples/               # Example programs
â”‚   â”œâ”€â”€ hello.as            # Basic IO effect
â”‚   â”œâ”€â”€ ownership.as        # Resource management
â”‚   â”œâ”€â”€ rows.as             # Row polymorphism
â”‚   â””â”€â”€ vectors.as          # Dependent types
â”œâ”€â”€ docs/                   # Documentation
â”‚   â””â”€â”€ wiki/               # Compiler & language documentation
â””â”€â”€ affinescript-spec.md    # Complete language specification (53KB)
----

== Documentation

* `affinescript-spec.md` â€” Complete language specification
* `docs/wiki/compiler/` â€” Compiler architecture and phase documentation
* `docs/wiki/language-reference/` â€” Language feature guides
* `docs/wiki/tutorials/` â€” Getting started guides

== Design Philosophy

. **Safety by default** â€” Ownership and effects make unsafe code explicit
. **Types as documentation** â€” Dependent types encode invariants in the type system
. **Composable abstractions** â€” Row polymorphism and effects compose cleanly
. **No runtime cost for safety** â€” Linear types enable compile-time resource management
. **Partial by default** â€” Functions may diverge unless marked `total`

== License

SPDX-License-Identifier: AGPL-3.0-or-later

== See Also

* link:ROADMAP.adoc[Development Roadmap]
* link:affinescript-spec.md[Language Specification]
